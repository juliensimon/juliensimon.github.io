<!DOCTYPE html>
<html lang="en">
 <head>
    <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  
  <!-- Primary Meta Tags -->
  <title>
<!-- Umami Analytics -->
<script defer src="https://cloud.umami.is/script.js" data-website-id="27550dad-d418-4f5d-ad1b-dab573da1020"></script>
<link rel="dns-prefetch" href="//cloud.umami.is">Is Running Language Models on CPU Really Viable? - Julien Simon | Small Language Model Expert</title>
  <meta name="title" content="Is Running Language Models on CPU Really Viable? - Julien Simon | Small Language Model Expert"/>
  <meta name="description" content="Expert analysis and technical deep-dive on is running language models on cpu really viable? by Julien Simon, leading voice in small language models and edge AI. Comprehensive insights on CPU inference, local AI deployment, and Arcee AI's innovative approaches."/>
  <meta name="keywords" content="Arcee AI, Small Language Models, SLMs, Edge AI, CPU Inference, Machine Learning, AI, Natural Language Processing, NLP, Julien Simon, AI Expert, Small Language Model Expert, Edge AI Expert, CPU AI, ARM CPUs, Intel Xeon, AI at the Edge, Local AI, Running, Language, Models, Really, Viable?"/>
  <meta name="author" content="Julien Simon"/>
  <meta name="robots" content="index, follow"/>
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="article"/>
  <meta property="og:url" content="https://julien.org/blog/2025-07-09-is-running-language-models-on-cpu-really-viable/"/>
  <meta property="og:title" content="Is Running Language Models on CPU Really Viable? - Julien Simon | Small Language Model Expert"/>
  <meta property="og:description" content="Expert analysis and technical deep-dive on is running language models on cpu really viable? by Julien Simon, leading voice in small language models and edge AI. Comprehensive insights on CPU inference, local AI deployment, and Arcee AI's innovative approaches."/>
  <meta property="og:image" content="https://julien.org/assets/julien-simon-arcee-expert.jpg"/>
  <meta property="og:site_name" content="Julien Simon - Small Language Model Expert"/>
  <meta property="article:author" content="Julien Simon"/>
  <meta property="article:published_time" content="2025-07-09T00:00:00Z"/>
  <meta property="article:section" content="Arcee AI"/>
  <meta property="article:tag" content="Arcee AI, Small Language Models, Edge AI, CPU Inference"/>
  
  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image"/>
  <meta property="twitter:url" content="https://julien.org/blog/2025-07-09-is-running-language-models-on-cpu-really-viable/"/>
  <meta property="twitter:title" content="Is Running Language Models on CPU Really Viable? - Julien Simon | Small Language Model Expert"/>
  <meta property="twitter:description" content="Expert analysis and technical deep-dive on is running language models on cpu really viable? by Julien Simon, leading voice in small language models and edge AI. Comprehensive insights on CPU inference, local AI deployment, and Arcee AI's innovative approaches."/>
  <meta property="twitter:image" content="https://julien.org/assets/julien-simon-arcee-expert.jpg"/>
  <meta property="twitter:creator" content="@julsimon"/>
  
  <!-- Canonical URL -->
  <link rel="canonical" href="https://julien.org/blog/2025-07-09-is-running-language-models-on-cpu-really-viable/"/>
  
  <!-- Author and Publisher -->
  <link rel="author" href="https://julien.org/"/>
  <link rel="publisher" href="https://julien.org/"/>
  
  <!-- Structured Data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "headline": "Is Running Language Models on CPU Really Viable?",
    "description": "Expert analysis and technical deep-dive on is running language models on cpu really viable? by Julien Simon, leading voice in small language models and edge AI. Comprehensive insights on CPU inference, local AI deployment, and Arcee AI's innovative approaches.",
    "image": "https://julien.org/assets/julien-simon-arcee-expert.jpg",
    "author": {
      "@type": "Person",
      "name": "Julien Simon",
      "url": "https://julien.org/",
      "jobTitle": "Small Language Model Expert & AI Evangelist",
      "worksFor": {
        "@type": "Organization",
        "name": "Arcee AI"
      },
      "sameAs": [
        "https://twitter.com/julsimon",
        "https://linkedin.com/in/juliensimon",
        "https://github.com/juliensimon"
      ]
    },
    "publisher": {
      "@type": "Organization",
      "name": "Julien Simon",
      "url": "https://julien.org/",
      "logo": {
        "@type": "ImageObject",
        "url": "https://julien.org/assets/julien-simon-logo.jpg"
      }
    },
    "datePublished": "2025-07-09T00:00:00Z",
    "dateModified": "2025-07-09T00:00:00Z",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://julien.org/blog/2025-07-09-is-running-language-models-on-cpu-really-viable/"
    },
    "url": "https://julien.org/blog/2025-07-09-is-running-language-models-on-cpu-really-viable/",
    "keywords": "Arcee AI, Small Language Models, SLMs, Edge AI, CPU Inference, Machine Learning, AI, Natural Language Processing, NLP, Julien Simon, AI Expert, Small Language Model Expert, Edge AI Expert, CPU AI, ARM CPUs, Intel Xeon, AI at the Edge, Local AI, Running, Language, Models, Really, Viable?",
    "articleSection": "Arcee AI",
    "inLanguage": "en-US",
    "isPartOf": {
      "@type": "Blog",
      "name": "Julien Simon - Small Language Model Expert Blog",
      "url": "https://julien.org/blog/"
    }
  }
  </script>
  
  <!-- Additional SEO Meta Tags -->
  <meta name="twitter:site" content="@julsimon"/>
  <meta name="twitter:creator" content="@julsimon"/>
  <meta name="theme-color" content="#FF6B35"/>
  <meta name="msapplication-TileColor" content="#FF6B35"/>
  <meta name="apple-mobile-web-app-capable" content="yes"/>
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
  
  <!-- Preconnect to external domains -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  
  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="https://julien.org/assets/favicon.ico">
  
  <!-- Security Headers -->
  <meta http-equiv="X-Content-Type-Options" content="nosniff">
  <meta http-equiv="X-Frame-Options" content="DENY">
  <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
  <meta http-equiv="X-XSS-Protection" content="1; mode=block">
  <meta http-equiv="Permissions-Policy" content="camera=(), microphone=(), geolocation=(), interest-cohort=()">
  <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
  <meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp">

  
  <style>
   body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            color: #333;
        }
        h1, h2, h3, h4, h5, h6 {
            color: #2c3e50;
            margin-top: 2em;
            margin-bottom: 0.5em;
        }
        h1 { font-size: 2.5em; }
        h2 { font-size: 2em; }
        h3 { font-size: 1.5em; }
        img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin: 1em 0;
        }
        /* Image alignment classes for text wraparound */
        img.alignleft {
            float: left;
            margin: 0.5em 1.5em 1em 0;
        }
        img.alignright {
            float: right;
            margin: 0.5em 0 1em 1.5em;
        }
        img.aligncenter {
            display: block;
            margin: 1em auto;
            float: none;
        }
        img.alignnone {
            float: none;
            margin: 1em 0;
        }
        /* Clear floats after images */
        .wp-block-image::after,
        p:has(img.alignleft)::after,
        p:has(img.alignright)::after {
            content: "";
            display: table;
            clear: both;
        }
        pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 1em;
            overflow-x: auto;
        }
        code {
            background: #f8f9fa;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: 'Monaco', 'Consolas', monospace;
        }
        blockquote {
            border-left: 4px solid #3498db;
            margin: 1em 0;
            padding-left: 1em;
            font-style: italic;
            color: #7f8c8d;
        }
        a {
            color: #3498db;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        p {
            margin-bottom: 1em;
        }
  </style>
 </head>
 <body>
  <h1>
   Is Running Language Models on CPU Really Viable?
  </h1>
  <p style="color: #666; font-style: italic; margin-bottom: 1em;">
   Published: 2025-07-09
  </p>
  <p style="color: #666; font-style: italic; margin-bottom: 2em;">
   Originally published at
   <a href="https://www.arcee.ai/blog/is-running-language-models-on-cpu-really-viable">
    https://www.arcee.ai/blog/is-running-language-models-on-cpu-really-viable
   </a>
  </p>
  <p>
   Running inference with large language models involves thousands of matrix multiplications, tensor operations, and other compute- and memory-intensive tasks. The need to perform these operations in parallel has made GPUs the natural choice for hosting models. However, GPUs come with one major drawback: everyone wants them, and they’re in limited supply, which drives up the cost.
  </p>
  <p>
   This fact has inspired companies like Meta, Microsoft, Alibaba, and Arcee AI to release small language models (SLMs), such as Llama, Phi, Qwen, and AFM, which can run efficiently on low VRAM GPUs. However, even these GPUs can have a prohibitive price tag if not managed properly, which begs the question: can we run SLMs without GPUs?
  </p>
  <p>
   In this blog, we’ll cover how small language models can run on CPUs. Using Arcee AI’s foundation model,
   <a href="https://afm.arcee.ai/">
    AFM-4.5B
   </a>
   , we’ll run benchmarks on Intel Sapphire Rapids, AWS Graviton4, and Qualcomm Z1E-80-100 processors at various quantizations, answering common questions along the way.
  </p>
  <h2>
   Is CPU inference just about cost?
  </h2>
  <p>
   Reducing cost isn’t the only advantage of CPU inference. Having the flexibility to run models on widely available hardware means it’s now possible to host models anywhere you’d like, particularly on your private infrastructure. You won’t need to worry about whether a company is storing your prompts, using your data to train their next model, or where it may be sending your confidential data. This makes it easier to meet your security, compliance, and governance requirements.
  </p>
  <p>
   Running language models on CPUs also opens up the possibility of edge and on-device deployment of models, where GPUs are extremely impractical due to technical and economic reasons.  Running models close to the end user also helps improve the user experience by reducing or even eliminating connectivity issues, solving the painful problem of “What happens if I lose my internet connection?”
  </p>
  <h2>
   Is CPU inference possible?
  </h2>
  <p>
   First, let’s address the elephant in the room. GPUs have thousands of cores and can handle massive amounts of parallel operations. Meanwhile, server CPUs typically have 64 cores and are designed to execute tasks sequentially. So, how can running models on a CPU deliver acceptable performance?
  </p>
  <p>
   There are three primary reasons:
  </p>
  <ul role="list">
   <li>
    Hardware acceleration features and instruction sets in modern CPU architectures
   </li>
   <li>
    Open-source innovation in quantization and model serving projects, such as
    <a href="https://github.com/ggml-org/llama.cpp">
     llama.cpp
    </a>
    ,
    <a href="https://github.com/vllm-project/vllm">
     vLLM
    </a>
    , and Intel
    <a href="https://github.com/openvinotoolkit/openvino">
     OpenVINO
    </a>
   </li>
   <li>
    Small language models that continue to shrink yet improve!
   </li>
  </ul>
  <h3>
   Hardware acceleration
  </h3>
  <p>
   Recent CPU architectures feature specialized instruction sets that accelerate low-precision matrix multiplications and other neural network operations, significantly enhancing inference throughput.
  </p>
  <p>
   For example, Intel Xeon
   <a href="https://en.wikipedia.org/wiki/Sapphire_Rapids">
    Sapphire Rapids
   </a>
   and
   <a href="https://en.wikipedia.org/wiki/Granite_Rapids">
    Granite Rapids
   </a>
   processors support hardware acceleration instruction sets, such as
   <a href="https://www.intel.com/content/www/us/en/products/docs/accelerator-engines/what-is-intel-avx-512.html">
    AVX-512
   </a>
   , Vector Neural Network Instructions (VNNI), and
   <a href="https://www.intel.com/content/www/us/en/products/docs/accelerator-engines/what-is-intel-amx.html">
    Advanced Matrix Extensions
   </a>
   (AMX). VNNI helps reduce the number of instructions required for common deep learning operations, such as convolutions and dot products, by fusing multiple steps into a single instruction. AMX further accelerates matrix-heavy workloads by introducing dedicated matrix multiplication hardware and larger tile-based registers. Together, these technologies significantly increase computational throughput and efficiency, making CPUs more competitive for AI inference workloads.
  </p>
  <p>
   Likewise,
   <a href="https://aws.amazon.com/ec2/graviton/">
    AWS Graviton4
   </a>
   processors, based on the
   <a href="https://www.arm.com/products/silicon-ip-cpu/neoverse/neoverse-v2">
    Arm Neoverse V2
   </a>
   architecture, offer significant improvements in performance and efficiency for a wide range of workloads, including deep learning inference. Graviton4 features enhanced vector processing capabilities through the Scalable Vector Extension (SVE). These vector instructions enable more efficient execution of parallel computations, such as matrix multiplications and tensor operations, which are crucial for running language models. With higher memory bandwidth, Graviton4 makes Arm-based CPUs an increasingly viable option for cost-effective AI inference at scale.
  </p>
  <h3>
   Open-Source Innovation
  </h3>
  <p>
   Model serving libraries, such as
   <strong>
    llama.cpp
   </strong>
   , take advantage of modern CPU instruction sets during inference to accelerate key operations. These libraries operate under constrained compute and memory environments—especially when running on CPUs instead of GPUs—so they employ a variety of clever optimization techniques to maximize efficiency.
  </p>
  <p>
   To reduce memory overhead, models are typically
   <strong>
    memory-mapped
   </strong>
   , a technique that allows only the necessary parts of the model to be loaded into RAM on demand rather than keeping the entire model in memory. This enables larger models to run on systems with limited RAM.
  </p>
  <p>
   A notable recent innovation is
   <strong>
    block interleaved weight repacking
   </strong>
   , which reorganizes model weights to better align with the wider vector registers and fused instructions available in modern CPUs (such as AVX-512, VNNI, and AMX). This approach significantly improves
   <strong>
    prompt processing speeds
   </strong>
   by allowing more efficient use of the CPU’s SIMD (single instruction, multiple data) capabilities.
  </p>
  <p>
   On the compute side, model-serving libraries use
   <strong>
    multi-threading
   </strong>
   to parallelize tensor operations across multiple CPU cores. By distributing the workload effectively—often by assigning different layers or chunks of computation to separate threads—they’re able to achieve much higher throughput and better latency, making CPU-based inference increasingly practical for real-world applications.
  </p>
  <h3>
   Small language models
  </h3>
  <p>
   Of course, none of the hardware or library improvements are relevant if there isn’t a small enough model that can fit within the compute and memory constraints of a CPU and is accurate enough to be used by businesses. Fortunately, over the past few years, models have continued to improve at an impressive rate, and smaller models are now approaching the same accuracy and capability levels as larger models.
   <a href="https://afm.arcee.ai/">
    AFM-4.5B
   </a>
   is an example of this.
  </p>
  <p>
   It’s important to note that 4.5 billion isn’t the largest model you can run on a CPU. We’ve found that even 70B models can run on a CPU with 4-bit quantization. However, the text generation speed is significantly slower than 10 tokens per second, which is too slow for comfort. For practical deployments, 8B models quantized to 4-bit, and 4B models using bfloat16 to 8-bit precision have shown strong performance.
  </p>
  <h2>
   Is CPU inference viable?
  </h2>
  <p>
   Now that we know it's possible to run models on a CPU, is it really viable? Can we achieve performance and maintain model accuracy that meets the requirements of an enterprise scenario? Spoiler alert: the answer is yes, and let’s dive into the proof.
  </p>
  <p>
   We evaluated AFM-4.5B utilizing llama.cpp on:
  </p>
  <ul role="list">
   <li>
    <strong>
     An Intel Xeon Sapphire Rapids processor
    </strong>
    (Amazon EC2 c7i) with 16 cores and two threads per core,
   </li>
   <li>
    <strong>
     An AWS Graviton 4 processor
    </strong>
    (Amazon EC2 c8g) with 32 vCPUs,
   </li>
   <li>
    A personal laptop configured with a
    <strong>
     Qualcomm X1E-80-100 processor
    </strong>
    with 12 cores and one thread per core.
   </li>
  </ul>
  <p>
   On each platform, we conducted 140 evaluations, combining different quantized variants of AFM-4.5B, input and output token lengths, and batch sizes. We recorded the size of the KV cache, prompt processing speed, token generation speed, overall latency, and other metrics. The quantization variants include bf16 (16-bit floating point), Q8_0 (Type 0, 8-bit), Q4_K_M (Medium K-means, 4-bit), Q4_1 (Type 1, 4-bit), and Q4_0 (Type 0, 4-bit), all in the llama.cpp GGUF format.
  </p>
  <h3>
   Quantization
  </h3>
  <p>
   If you’re familiar with quantization, you may now be thinking, “Quantizing down to 8 and 4 bits must really reduce the accuracy of the model.” For basic quantization techniques, you’d be correct. However, current techniques, such as K-Quants and I-Quants, implement clever algorithms to maintain more relevant information at lower quantizations. For example, when measuring the perplexity of AFM-4.5B, we found that quantizing from bf-16 to 8-bit had no impact. Interestingly, going from 8-bit to 4-bit only increased perplexity by 1% (lower perplexity is better).
  </p>
  <h3>
   Results
  </h3>
  <h4>
   <strong>
    Intel Xeon Sapphire Rapids
   </strong>
  </h4>
  <p>
   We’ll start by looking at AFM-4.5B on the Intel Xeon Sapphire Rapids Processor. When utilizing all 32 threads, we achieved an average of 136.77 total tokens per second (TPS) for the Q4_0 quantized variant with a batch size of 4. With the same configurations, the bf16 variant achieved an average of 83.13 TPS. These numbers are quite impressive!
  </p>
  <figure class="w-richtext-align-fullwidth w-richtext-figure-type-image" style="max-width:990pxpx">
   <div>
    <img alt="Average Total Throughput by Batch Size on Intel" loading="lazy" src="image01.webp"/>
   </div>
   <figcaption>
    Average Total Throughput by Batch Size on Intel
   </figcaption>
  </figure>
  <p>
   As expected, given the limited parallelism of CPUs, we observe below a drop in TPS per request as the batch size increases; however, with the lowest TPS of 20.79 for AFM-4.5B in bf16, this configuration provides viable speed for the vast majority of production use cases.
  </p>
  <figure class="w-richtext-align-fullwidth w-richtext-figure-type-image" style="max-width:992pxpx">
   <div>
    <img alt="Average Total Throughput by Batch Size on Intel" loading="lazy" src="image02.webp"/>
   </div>
   <figcaption>
    Average Tokens per Second per Request by Batch Size on Intel
   </figcaption>
  </figure>
  <p>
   Now, let’s examine the time to first token (TTFT). Besides networking latency and handling request queues, the primary contributor to TTFT is populating the KV cache, also known as pre-fill. This process involves the self-attention mechanism calculating the interactions between each token in the input sequence and all other tokens in the sequence. Given that CPUs don’t have the parallelization capabilities of GPUs, we’d expect this process to take significantly longer than on GPUs.
  </p>
  <p>
   However, as shown below, the TTFT remains very manageable, with smaller quantizations staying below 2 seconds for all batch sizes and bf16 approaching 2 seconds (specifically, 2.075 seconds) for batch sizes of 4.
  </p>
  <p>
   Note: We used continuous batching, which helps reduce TTFT as the batch size increases.
  </p>
  <figure class="w-richtext-align-fullwidth w-richtext-figure-type-image" style="max-width:1220pxpx">
   <div>
    <img alt="Time to First Token per Request By Batch Size on Intel" loading="lazy" src="image03.webp"/>
   </div>
   <figcaption>
    Time to First Token per Request By Batch Size on Intel
   </figcaption>
  </figure>
  <p>
   ‍
   <strong>
    AWS Graviton 4
   </strong>
   ‍
  </p>
  <p>
   Graviton is an ARM-based processor developed by Amazon Web Services, designed to deliver the best cost-performance ratio for cloud computing workloads. In our tests, Graviton performs exceptionally well for 4- and 8-bit quantized variants of AFM-4.5B, with Q4_0 reaching above 280 TPS at a batch size of 4.
  </p>
  <p>
   It’s important to note that we did not include BF16 in these graphs because, at the time of publishing this blog, llama.cpp does not leverage ARM bf16 or SVEbf16 instructions to accelerate CPU inference. If you load a BF16 variant of a model, the data is upcast to FP32, resulting in very poor performance (~2 TPS at all batch sizes). We felt that this was not a fair comparison to include.
  </p>
  <figure class="w-richtext-align-fullwidth w-richtext-figure-type-image" style="max-width:990pxpx">
   <div>
    <img alt="Average Total Throughput by Batch Size on Graviton" loading="lazy" src="image04.webp"/>
   </div>
   <figcaption>
    Average Total Throughput by Batch Size on Graviton
   </figcaption>
  </figure>
  <p>
   The per-request TPS remains extremely viable at a batch size of 4, maintaining throughput of around 35-40 TPS.
  </p>
  <figure class="w-richtext-align-fullwidth w-richtext-figure-type-image" style="max-width:988pxpx">
   <div>
    <img alt="Average Total Throughput by Batch Size on Graviton" loading="lazy" src="image05.webp"/>
   </div>
   <figcaption>
    Average Tokens per Second per Request by Batch Size on Graviton
   </figcaption>
  </figure>
  <p>
   Time-to-first-token increases slightly compared to the Intel processor.
  </p>
  <figure class="w-richtext-align-fullwidth w-richtext-figure-type-image" style="max-width:1270pxpx">
   <div>
    <img alt="Average Total Throughput by Batch Size on Graviton" loading="lazy" src="image06.webp"/>
   </div>
   <figcaption>
    Average Time to First Token per Request by Batch Size on Graviton
   </figcaption>
  </figure>
  <h4>
   <strong>
    Qualcomm X1E-80-100
   </strong>
  </h4>
  <p>
   The final hardware we tested was a personal laptop with a Qualcomm X1E-80-100 processor. We conducted this evaluation to see how AFM-4.5B would perform on a smaller CPU. The Qualcomm processor has only 12 logical cores compared to the 32 that the Intel Sapphire Rapids and AWS Graviton processors have. We were pleased to discover that Q8_0, Q4_1, and Q4_0 were all viable options.
  </p>
  <figure class="w-richtext-align-fullwidth w-richtext-figure-type-image" style="max-width:1006pxpx">
   <div>
    <img alt="Average Time to First Token per Request by Batch Size on Graviton" loading="lazy" src="image07.webp"/>
   </div>
   <figcaption>
    Average Total Throughput by Batch Size on Qualcomm
   </figcaption>
  </figure>
  <p>
   Both total throughput and average TPS per request perform as expected on the smaller hardware. An interesting finding during the evaluation was the significant impact repacking had on this processor.  Repacking is the process of dynamically reorganizing quantized model weights in memory during loading in order to optimize them for a specific CPU architecture. We found that repacking nearly doubled prompt processing speed and increased text generation speed by ~50%.
  </p>
  <figure class="w-richtext-align-fullwidth w-richtext-figure-type-image" style="max-width:1024pxpx">
   <div>
    <img alt="Average Total Throughput by Batch Size on Qualcomm" loading="lazy" src="image08.webp"/>
   </div>
   <figcaption>
    Average Tokens per Second per Request by Batch Size on Qualcomm
   </figcaption>
  </figure>
  <p>
   Time-to-first token was drastically higher than the Intel and Graviton tests. A major consideration here is how much the prompt length impacted TTFT. One would expect that longer prompt lengths would increase TTFT; however, we found a larger impact during the Qualcomm test.
  </p>
  <p>
   For example, when the input prompt was 128 tokens for the Q4_0 variant at a batch size of 1, the average TTFT was 0.94 seconds. This time increased to 10.94 seconds when the input prompt expanded to 1024 tokens. Similarly, the average TTFT for 128 input tokens with the Q8_0 variant at a batch size of 1 was 3.45 seconds, and it increased to 27.83 seconds for 1024 input tokens.
  </p>
  <p>
   Thus, it would be reasonable to limit inference on the Qualcomm X1E-80-100 processor to short-context questions, excluding applications like Retrieval-Augmented Generation or document analysis.
  </p>
  <figure class="w-richtext-align-fullwidth w-richtext-figure-type-image" style="max-width:1274pxpx">
   <div>
    <img alt="Average Time to First Token per Request by Batch Size on Qualcomm" loading="lazy" src="image09.webp"/>
   </div>
   <figcaption>
    Average Time to First Token per Request by Batch Size on Qualcomm
   </figcaption>
  </figure>
  <h2>
   Is CPU inference right for your use case?
  </h2>
  <p>
   The results above demonstrate that SLM inference on CPUs can achieve a production-level performance; however, performance is fully dependent on the requirements of your use case. Based on our findings, to determine if you should use CPU inference, you should consider the following:
  </p>
  <ol role="list">
   <li>
    From our tests,
    <strong>
     a batch size of 4 is really as high as you’d want to go
    </strong>
    . If you require a large number of concurrent requests, you’ll need to scale out the number of hosted models. At that point, you may be better off running on a small to medium-sized GPU, such as a single L40S, as it’ll be much simpler to manage, and you can achieve over 100 concurrent requests.
   </li>
   <li>
    <strong>
     You need to keep the context length relatively short
    </strong>
    . When running the model in bfloat16 and Q4_0, an input sequence length of 1024 and output length of 1024 allowed for a maximum batch size of 2. To increase the batch size to 4, both the input and output token lengths had to be reduced to 512.
   </li>
   <li>
    <strong>
     You need to leverage quantized models
    </strong>
    . Running full-precision models on a CPU doesn’t yield high performance, so you need to ensure the model you’re running is accurate enough for your use case when quantized.
   </li>
  </ol>
  <h2>
   Conclusion
  </h2>
  <p>
   While GPUs still dominate for high-throughput, low-latency workloads, CPUs—when paired with small, well-quantized models and optimized serving libraries—can absolutely deliver production-level performance. Our benchmarks demonstrate that, with the right hardware, quantization strategy, and batch size tuning, CPUs are not only viable but can also be an excellent choice for cost-sensitive, latency-tolerant, and privacy-conscious deployments.
  </p>
  <p>
   Ultimately, CPU inference won’t replace GPUs for every use case. Still, it opens up new possibilities—especially for edge, on-device, and secure enterprise applications where GPU access is limited or impractical. As small model quality continues to improve and hardware acceleration becomes more capable, the case for running language models on CPUs will only get stronger.
  </p>
  <p>
   If you’re curious about whether running an SLM on a CPU would work for your use case, please contact the Arcee AI team
   <a href="https://www.arcee.ai/book-a-demo">
    here
   </a>
   .
  </p>
 </body>
</html>
