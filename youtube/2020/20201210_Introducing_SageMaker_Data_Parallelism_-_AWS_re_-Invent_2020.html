<!DOCTYPE html>

<html lang="en">
<head>
<meta content="Introducing SageMaker Data Parallelism   AWS re  Invent 2020 - In this video, I show how you to use the new data parallelism capability in Amazon SageMaker, and how to adapt your TensorFlow code for it.

* https://aws.amazo..." name="description"/><meta content="Introducing SageMaker Data Parallelism   AWS re  Invent 2020 - Julien Simon" property="og:title"/><meta content="Introducing SageMaker Data Parallelism   AWS re  Invent 2020 - In this video, I show how you to use the new data parallelism capability in Amazon SageMaker, and how to adapt your TensorFlow code for it.

* https://aws.amazo..." property="og:description"/><meta content="https://www.julien.org/youtube/2020/20201210_Introducing_SageMaker_Data_Parallelism_-_AWS_re_-Invent_2020.html" property="og:url"/><meta content="video" property="og:type"/><meta content="summary_large_image" name="twitter:card"/><meta content="Introducing SageMaker Data Parallelism   AWS re  Invent 2020 - Julien Simon" name="twitter:title"/><meta content="Introducing SageMaker Data Parallelism   AWS re  Invent 2020 - In this video, I show how you to use the new data parallelism capability in Amazon SageMaker, and how to adapt your TensorFlow code for it.

* https://aws.amazo..." name="twitter:description"/><link href="https://www.julien.org/youtube/2020/20201210_Introducing_SageMaker_Data_Parallelism_-_AWS_re_-Invent_2020.html" rel="canonical"/><meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Introducing SageMaker Data Parallelism   AWS re  Invent 2020 - Julien Simon</title>
<style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.2em;
        }
        .date {
            color: #7f8c8d;
            font-size: 1.1em;
            margin-bottom: 30px;
            font-weight: 500;
        }
        .video-container {
            position: relative;
            width: 100%;
            height: 0;
            padding-bottom: 56.25%; /* 16:9 aspect ratio */
            margin-bottom: 30px;
        }
        .video-container iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 8px;
        }
        .description {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            white-space: pre-wrap;
            font-size: 1em;
        }
        .description a {
            color: #3498db;
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s;
        }
        .description a:hover {
            color: #2980b9;
            text-decoration: underline;
        }
        .transcript {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            white-space: pre-wrap;
            font-size: 1em;
        }
        .transcript h2 {
            color: #2c3e50;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.5em;
        }
        .tags {
            margin-bottom: 30px;
        }
        .tags h2 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.5em;
        }
        .tag {
            display: inline-block;
            background: #3498db;
            color: white;
            padding: 6px 12px;
            margin: 4px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 500;
        }
        .links {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .link {
            display: inline-block;
            padding: 12px 24px;
            background: #3498db;
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-weight: 500;
            transition: background-color 0.3s;
        }
        .link:hover {
            background: #2980b9;
        }
        .link.youtube {
            background: #e74c3c;
        }
        .link.youtube:hover {
            background: #c0392b;
        }
        @media (max-width: 600px) {
            .container {
                padding: 20px;
                margin: 10px;
            }
            h1 {
                font-size: 1.8em;
            }
            .links {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
<div class="container">
<h1>Introducing SageMaker Data Parallelism   AWS re  Invent 2020</h1>
<div class="date">December 10, 2020</div>
<div class="video-container">
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" src="https://www.youtube.com/embed/qS4VgHocAGQ">
</iframe>
</div>
<div class="description">In this video, I show how you to use the new data parallelism capability in Amazon SageMaker, and how to adapt your TensorFlow code for it.

* <a href="https://aws.amazon.com/blogs/aws/managed-data-parallelism-in-amazon-sagemaker-simplifies-training-on-large-datasets/" rel="noopener noreferrer" target="_blank">https://aws.amazon.com/blogs/aws/managed-data-parallelism-in-amazon-sagemaker-simplifies-training-on-large-datasets/</a>
* <a href="https://github.com/aws/amazon-sagemaker-examples/tree/master/training/distributed_training/tensorflow/data_parallel" rel="noopener noreferrer" target="_blank">https://github.com/aws/amazon-sagemaker-examples/tree/master/training/distributed_training/tensorflow/data_parallel</a>
* <a href="https://sagemaker.readthedocs.io/en/stable/api/training/distributed.html" rel="noopener noreferrer" target="_blank">https://sagemaker.readthedocs.io/en/stable/api/training/distributed.html</a>

⭐️⭐️⭐️ Don't forget to subscribe to be notified of future episodes ⭐️⭐️⭐️

For more content:
* AWS blog: <a href="https://aws.amazon.com/blogs/aws/" rel="noopener noreferrer" target="_blank">https://aws.amazon.com/blogs/aws/</a>
* Medium blog: <a href="https://julsimon.medium.com/" rel="noopener noreferrer" target="_blank">https://julsimon.medium.com/</a>
* YouTube: <a href="https://youtube.com/juliensimonfr" rel="noopener noreferrer" target="_blank">https://youtube.com/juliensimonfr</a> 
* Podcast: <a href="http://julsimon.buzzsprout.com" rel="noopener noreferrer" target="_blank">http://julsimon.buzzsprout.com</a> 
* Twitter <a href="https://twitter.com/@julsimon" rel="noopener noreferrer" target="_blank">https://twitter.com/@julsimon</a></div>
<div class="transcript">
<h2>Transcript</h2>
            Hi everybody, this is Julien from Arcee. In this video, I would like to introduce a new distributed training capability available in Amazon SageMaker. We just launched it at AWS Reinvent, and this one is SageMaker Data Parallelism. Let me explain what data parallelism is first. Data parallelism is a way to train on really large data sets by splitting the training data and distributing it to multiple training instances. Of course, when you have very large data sets for deep learning training jobs like computer vision or natural language processing, this is a really useful technique. Distributed training was already available in SageMaker, so it's not entirely new. What's the big difference here? This new data parallelism technique is more efficient. It removes GPU to GPU communication, which is how AuroVod works. AuroVod is great, but as you scale to really large training jobs, the network becomes a bottleneck, and there's just too much chatter going on between GPUs. SageMaker Data Parallelism, or SDP for short, removes that. Let me show you how this works. 

Here, the data is distributed to different GPUs. A subset of the dataset is sent to each GPU. Each GPU trains the model on that subset of data and stores gradients, or parameter updates, in GPU memory. When a certain threshold is reached, it sends those gradients to the instance CPUs. The CPUs themselves will apply the gradient updates coming from the different GPUs, reduce those, and then send them back to the GPUs. As you can see, the GPUs don't talk to one another, so they can stay hopefully 100% busy on training and not on communicating. Another benefit is that we don't need dedicated infrastructure. We don't need parameter servers to receive gradients, consolidate updates, and distribute them back. Both the training part and the model updating part are distributed on your training cluster. You don't need anything else. Training on the GPU and consolidation and model updates on the CPUs all stay within your cluster, making this more efficient.

Let's do an example. In the blog post, I have a PyTorch example, but let's do a TensorFlow example. First, let me show you where you can find these. They're in the Amazon SageMaker examples repository. You need to go to training and distributed training. You have examples for TensorFlow and PyTorch. Let's look at data parallelism first through a simple example to show you what it takes to modify your existing code for SDP. There are also larger scale examples using BERT and CNN where you use Amazon FSX for Lustre to store the training set and speed up the training job even further. These are really good examples but are a bit too long for this video. I'm going to use the simple example here. You can find the documentation for this on readthedocs.io. I will put all those links in the video description, including API information for PyTorch and TensorFlow and a guide explaining how to adapt your existing code for SDP.

The first major thing is to update your SageMaker SDK. Otherwise, you won't have the data parallel APIs. At the time of recording, the latest version is 2.19, and it works for me. If you have 2.19 or newer, you should be fine. Now, let's look at the training code and focus specifically on what you need to add to make this run with SageMaker data parallelism. First, we need to import the package and initialize it. That wasn't too hard. Then, you need to pin the GPUs running on a particular instance to the data parallel process running on that instance. The data parallel process will manage the GPUs present on the instance, so you just need to declare those GPUs as associated with that process. This is the line of code you need to add here.

We load the dataset, build a TensorFlow dataset object, shuffle it, and so on. We build our model, select the loss function, and then, as we can see, we multiply the learning rate by the size of the training cluster. For example, if you have eight nodes, then we multiply the learning rate by eight. We use checkpointing, which is always a good idea in case you have long-lasting jobs. If something fails or if you need to restart them or resume from a checkpoint and train further, this is always good. Then we have the training step function. This uses the gradient tape TensorFlow object, which records all the forward propagation operations so that you can automatically compute gradients during backprop. You can keep using gradient tape. All you need to do is wrap it using distributed gradient tape from the SDK. Simple enough. The rest is as usual. Compute gradients, apply gradients, and if this is the first batch, so if the training job is just starting, we need to broadcast variables to all nodes. This only happens once. So here, just grab the variables from your model and broadcast them. Of course, we need to reduce all the gradient updates. We call the all-reduce operation from the SDK, which will collect and process the different updates coming from all the different nodes. We return the loss value. The rest is identical.

Finally, in the training loop, we only checkpoint on the master node. It's probably just a waste of storage to have a checkpoint on every single node. Here, if the node is node 0, if it's the leader node, then we checkpoint there. That's all we need to know. Summing things up, not such a large amount of work. Import the package, initialize it, pin the GPUs to the SDP processes running on each node of the cluster, multiply the learning rate accordingly, use the distributed gradient tape object for backward propagation, compute the reduce operation for the loss, and checkpoint only on the leader node. All right, so that's about it. Not a lot of work. We create a TensorFlow estimator, passing our script. We use TensorFlow 2.3.1, Python 3.7, and two p3.16xlarge instances, which is a total of 16 GPUs. This is a lot for MNIST, but it's a simple example. Then we just enable data parallelism like this, setting the distributed training configuration to data parallelism, just enabling it. One thing to know is that this is only available for three instance sizes: p3.16xlarge, p3dn.24xlarge, and p4d.24xlarge. This makes sense because if you are facing very large training jobs, you would certainly be using the larger GPU instances. We just run the training job and wait. It's a totally normal-looking training job, except that this time you're using this new algorithm instead of the native parameter server available in TensorFlow or Horovod. Swami in his keynote announced some benchmarks that were pretty spectacular, thanks to these new distributed training features on SageMaker. Go and take a look at the keynote if you haven't seen it.

That's what I wanted to tell you. Have fun scaling your training jobs with data parallelism. It's a really nice addition and doesn't take a lot of changes to your code. Let me know how you're doing. Happy to answer questions and listen to feedback. See you soon. Thank you.
        </div>
<div class="tags">
<h2>Tags</h2>
<span class="tag">Amazon SageMaker</span><span class="tag">Data Parallelism</span><span class="tag">Distributed Training</span><span class="tag">Machine Learning</span><span class="tag">TensorFlow</span>
</div>
<div class="links"><a class="link" href="../../index.html">← Back to YouTube Overview</a></div>
</div>
</body>
</html>